# 组合模式（Composite Pattern）

## 简述

![](https://picb.zhimg.com/80/v2-520eac5b22bc06aee7083a85568be75c_1440w.jpg)

在面向对象编程中，有两个常见的对象设计方法，组合和继承，两者都可以解决代码复用的问题，但是使用后者时容易出现继承层次过深，对象关系过于复杂的副作用，从而导致代码的可维护性变差。因此，一个经典的面向对象设计原则是：组合优于继承。

我们都知道，组合所表示的语义为“has-a”，也就是部分和整体的关系，最经典的组合模式描述如下：

将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
Go语言天然就支持了组合模式，而且从它不支持继承关系的特点来看，Go也奉行了组合优于继承的原则，鼓励大家在进行程序设计时多采用组合的方法。Go实现组合模式的方式有两种，分别是直接组合（Direct Composition）和嵌入组合（Embedding Composition），下面我们一起探讨这两种不同的实现方法。

## Go实现

直接组合（Direct Composition）的实现方式类似于Java/C++，就是将一个对象作为另一个对象的成员属性。

一个典型的实现如《使用Go实现GoF的23种设计模式（一）》中所举的例子，一个Message结构体，由Header和Body所组成。那么Message就是一个整体，而Header和Body则为消息的组成部分。

# 适配器模式（Adapter Pattern）

## 简述

![](https://pic2.zhimg.com/80/v2-1e71f33c671701a5b9a09e2909337317_1440w.jpg)

适配器模式是最常用的结构型模式之一，它让原本因为接口不匹配而无法一起工作的两个对象能够一起工作。在现实生活中，适配器模式也是处处可见，比如电源插头转换器，可以让英式的插头工作在中式的插座上。适配器模式所做的就是将一个接口Adaptee，通过适配器Adapter转换成Client所期望的另一个接口Target来使用，实现原理也很简单，就是Adapter通过实现Target接口，并在对应的方法中调用Adaptee的接口实现。

一个典型的应用场景是，系统中一个老的接口已经过时即将废弃，但因为历史包袱没法立即将老接口全部替换为新接口，这时可以新增一个适配器，将老的接口适配成新的接口来使用。适配器模式很好的践行了面向对象设计原则里的开闭原则（open/closed principle），新增一个接口时也无需修改老接口，只需多加一个适配层即可。

## Go实现

继续考虑上一节的消息处理系统例子，目前为止，系统的输入都源自于HelloInput，现在假设需要给系统新增从Kafka消息队列中接收数据的功能，其中Kafka消费者的接口如下：

# 桥接模式（Bridge Pattern）

## 简述

![](https://picb.zhimg.com/80/v2-d6d74094768393c5659b26f6b328b596_1440w.jpg)

桥接模式主要用于将抽象部分和实现部分进行解耦，使得它们能够各自往独立的方向变化。它解决了在模块有多种变化方向的情况下，用继承所导致的类爆炸问题。举一个例子，一个产品有形状和颜色两个特征（变化方向），其中形状分为方形和圆形，颜色分为红色和蓝色。如果采用继承的设计方案，那么就需要新增4个产品子类：方形红色、圆形红色、方形蓝色、圆形红色。如果形状总共有m种变化，颜色有n种变化，那么就需要新增m*n个产品子类！现在我们使用桥接模式进行优化，将形状和颜色分别设计为一个抽象接口独立出来，这样需要新增2个形状子类：方形和圆形，以及2个颜色子类：红色和蓝色。同样，如果形状总共有m种变化，颜色有n种变化，总共只需要新增m+n个子类！

![](https://pic1.zhimg.com/80/v2-cbdab0421904cd246661635a74bc941e_1440w.jpg)

上述例子中，我们通过将形状和颜色抽象为一个接口，使产品不再依赖于具体的形状和颜色细节，从而达到了解耦的目的。桥接模式本质上就是面向接口编程，可以给系统带来很好的灵活性和可扩展性。如果一个对象存在多个变化的方向，而且每个变化方向都需要扩展，那么使用桥接模式进行设计那是再合适不过了。

## Go实现

回到消息处理系统的例子，一个Pipeline对象主要由Input、Filter、Output三类插件组成（3个特征），因为是插件化的系统，不可避免的就要求支持多种Input、Filter、Output的实现，并能够灵活组合（有多个变化的方向）。显然，Pipeline就非常适合使用桥接模式进行设计，实际上我们也这么做了。我们将Input、Filter、Output分别设计成一个抽象的接口，它们按照各自的方向去扩展。Pipeline只依赖的这3个抽象接口，并不感知具体实现的细节。

![](https://pic4.zhimg.com/80/v2-2491deeaacdf69f7d369edbc51734970_1440w.jpg)

# 总结

本文主要介绍了结构型模式中的组合模式、适配器模式和桥接模式。组合模式主要解决代码复用的问题，相比于继承关系，组合模式可以避免继承层次过深导致的代码复杂问题，因此面向对象设计领域流传着组合优于继承的原则，而Go语言的设计也很好实践了该原则；适配器模式可以看作是两个不兼容接口之间的桥梁，可以将一个接口转换成client所希望的另外一个接口，解决了模块之间因为接口不兼容而无法一起工作的问题；桥接模式将模块的抽象部分和实现部分进行分离，让它们能够往各自的方向扩展，从而达到解耦的目的。

下一篇文章，我们将继续聚焦于结构型模式，介绍完剩余的4种结模式：装饰模式、外观模式、享元模式和代理模式。

# 代理模式（Proxy Pattern）

## 简介

![https://pic3.zhimg.com/80/v2-349bb4bf0e91a0af3fb21ae725062e4b_720w.jpg](https://pic3.zhimg.com/80/v2-349bb4bf0e91a0af3fb21ae725062e4b_720w.jpg)

代理模式为一个对象提供一种代理以控制对该对象的访问，它是一个使用率非常高的设计模式，即使在现实生活中，也是很常见，比如演唱会门票黄牛。假设你需要看一场演唱会，但是官网上门票已经售罄，于是就当天到现场通过黄牛高价买了一张。在这个例子中，黄牛就相当于演唱会门票的代理，在正式渠道无法购买门票的情况下，你通过代理完成了该目标。

从演唱会门票的例子我们也可以看出，使用代理模式的关键在于当Client不方便直接访问一个对象时，提供一个代理对象控制该对象的访问。Client实际上访问的是代理对象，代理对象会将Client的请求转给本体对象去处理。

在程序设计中，代理模式也分为好几种：

1、`远程代理（remote proxy）`，远程代理适用于提供服务的对象处在远程的机器上，通过普通的函数调用无法使用服务，需要经过远程代理来完成。因为并不能直接访问本体对象，所有远程代理对象通常不会直接持有本体对象的引用，而是持有远端机器的地址，通过网络协议去访问本体对象。

2、`虚拟代理（virtual proxy）`，在程序设计中常常会有一些重量级的服务对象，如果一直持有该对象实例会非常消耗系统资源，这时可以通过虚拟代理来对该对象进行延迟初始化。

3、`保护代理（protection proxy）`，保护代理用于控制对本体对象的访问，常用于需要给Client的访问加上权限验证的场景。

4、`缓存代理（cache proxy）`，缓存代理主要在Client与本体对象之间加上一层缓存，用于加速本体对象的访问，常见于连接数据库的场景。

5、`智能引用（smart reference）`，智能引用为本体对象的访问提供了额外的动作，常见的实现为C++中的智能指针，为对象的访问提供了计数功能，当访问对象的计数为0时销毁该对象。

这几种代理都是一样的实现原理，下面我们将介绍远程代理的Go语言实现。

## Go实现

考虑要将消息处理系统输出到数据存储到一个数据库中，数据库的接口如下：

# 装饰模式（Decorator Pattern）

## 简介

![](https://pic3.zhimg.com/80/v2-29c7738e613d9f8a4c353be5b6a37ecb_1440w.jpg)

在程序设计中，我们常常需要为对象添加新的行为，很多同学的第一个想法就是扩展本体对象，通过继承的方式达到目的。但是使用继承不可避免地有如下两个弊端：（1）继承时静态的，在编译期间就已经确定，无法在运行时改变对象的行为。（2）子类只能有一个父类，当需要添加的新功能太多时，容易导致类的数量剧增。

对于这种场景，我们通常会使用装饰模式（Decorator Pattern）来解决，它使用组合而非继承的方式，能够动态地为本体对象叠加新的行为。理论上，只要没有限制，它可以一直把功能叠加下去。装饰模式最经典的应用当属Java的I/O流体系，通过装饰模式，使用者可以动态地为原始的输入输出流添加功能，比如按照字符串输入输出，添加缓存等，使得整个I/O流体系具有很高的可扩展性和灵活性。

从结构上看，装饰模式和代理模式具有很高的相似性，但是两种所强调的点不一样。前者强调的是为本体对象添加新的功能，后者强调的是对本体对象的访问控制。当然，代理模式中的智能引用在笔者看来就跟装饰模式完全一样了。

## Go实现

考虑为消息处理系统增加这样的一个功能，统计每个消息输入源分别产生了多少条消息，也就是分别统计每个Input产生Message的数量。最简单的方法是在每一个Input的Receive方法中进行打点统计，但是这样会导致统计代码与业务代码的耦合。如果统计逻辑发生了变化，就会产生霰弹式修改，随着Input类型的增多，相关代码也会变得越来越难维护。

更好的方法是将统计逻辑放到一个地方，并在每次调用Input的Receive方法后进行打点统计。而这恰好适合采用装饰模式，为Input（本体对象）提供打点统计功能（新的行为）。我们可以设计一个InputMetricDecorator作为Input的装饰器，在装饰器中完成打点统计的逻辑。

首先，我们需要设计一个用于统计每个Input产生Message数量的对象，该对象应该是一个全局唯一的，因此采用单例模式进行了实现：


# 外观模式（Facade Pattern）

![](https://pic4.zhimg.com/80/v2-e8a55c20a88f2e268aea3ba33c5ac097_1440w.jpg)

## 简介

从结构上看，外观模式非常的简单，它主要是为子系统提供了一个更高层次的对外统一接口，使得Client能够更友好地使用子系统的功能。图中，Subsystem Class是子系统中对象的简称，它可能是一个对象，也可能是数十个对象的集合。外观模式降低了Client与Subsystem之间的耦合，只要Facade不变，不管Subsystem怎么变化，对于Client而言都是无感知的。

![](https://pic3.zhimg.com/80/v2-dfbb2b7625873d3bb05efe82f4fea508_1440w.jpg)

外观模式在程序设计中用的非常多，比如我们在商城上点击购买的按钮，对于购买者而言，只看到了购买这一统一的接口，但是对于商城系统而言，其内部则进行了一系列的业务处理，比如库存检查、订单处理、支付、物流等等。外观模式极大地提升了用户体验，将用户从复杂的业务流程中解放了出来。

外观模式经常运用于分层架构上，通常我们都会为分层架构中的每一个层级提供一个或多个统一对外的访问接口，这样就能让各个层级之间的耦合性更低，使得系统的架构更加合理。

## Go实现

外观模式实现起来也很简单，还是考虑前面的消息处理系统。在Pipeline中，每一条消息会依次经过Input->Filter->Output的处理，代码实现起来就是这样